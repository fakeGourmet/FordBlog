{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{492:function(n,a,t){\"use strict\";t.r(a);var e=t(4),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"_1-常量和变量\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-常量和变量\"}},[n._v(\"#\")]),n._v(\" 1 常量和变量\")]),n._v(\" \"),t(\"p\",[n._v(\"使用let定义变量，表示该值不可再被更改\\n使用var定义变量 ，表示将来可以被修改为不同的值\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"_1-1-常量声明\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-1-常量声明\"}},[n._v(\"#\")]),n._v(\" 1.1 常量声明\")]),n._v(\" \"),t(\"div\",{staticClass:\"language-swift extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-swift\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[n._v(\"//定义数据类型\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" score \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\":\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[n._v(\"Double\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"88.8\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[n._v(\"//定义对象\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" view \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\":\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[n._v(\"UIView\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"UIView\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),n._v(\"\\n\")])])]),t(\"h2\",{attrs:{id:\"_1-2-变量声明\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-2-变量声明\"}},[n._v(\"#\")]),n._v(\" 1.2 变量声明\")]),n._v(\" \"),t(\"div\",{staticClass:\"language-swift extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-swift\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"var\")]),n._v(\" age \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\":\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[n._v(\"Int\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"23\")]),n._v(\"\\nage \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"13\")]),n._v(\"\\n\")])])]),t(\"h2\",{attrs:{id:\"_1-3-常量和变量的注意点\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-3-常量和变量的注意点\"}},[n._v(\"#\")]),n._v(\" 1.3 常量和变量的注意点\")]),n._v(\" \"),t(\"ol\",[t(\"li\",[n._v(\"在开发中，一般优先使用常量，只有发现标识符需要修改时，在使用变量，这样做防止我们在不希望它值修改的情况下，在其他地方被修改。\")]),n._v(\" \"),t(\"li\",[n._v(\"常量的本质：标识符指向的内存地址不可以被修改，但是可以通过内存地址找到对应的对象，修改对象内部的属性。\")]),n._v(\" \"),t(\"li\",[n._v(\"省略：上面例子中\"),t(\"code\",[n._v(\":Double\")]),n._v(\" 和 \"),t(\"code\",[n._v(\":Int\")]),n._v(\"是可以省略的，事实上，我们也不需要经常使用类型标注，如果在定义一个变量或常量的时候就初始化一个值，那么Swift就可以推断出这个变量或常量的类型， 可以通过\"),t(\"code\",[n._v(\"option + 鼠标左键\")]),n._v(\"来查看标识符类型。\")])]),n._v(\" \"),t(\"div\",{staticClass:\"language-swift extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-swift\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" score \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"88.8\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"+\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"10\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[n._v(\"//swift会识别类型为 Double\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" view \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"UIView\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),n._v(\"\\n\")])])]),t(\"ol\",{attrs:{start:\"4\"}},[t(\"li\",[n._v(\"标识符名称，也就是变量和常量的名字不能包含空白字符、数学符号、箭头、保留的或者无效的Unicode码位、连线和制表符，也不能以数字开头。\")])]),n._v(\" \"),t(\"h2\",{attrs:{id:\"_1-4-if-let-和-if-var\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-4-if-let-和-if-var\"}},[n._v(\"#\")]),n._v(\" 1.4 if let 和 if var\")]),n._v(\" \"),t(\"p\",[n._v(\"对if var 的改变不影响原值。\")]),n._v(\" \"),t(\"div\",{staticClass:\"language-swift extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-swift\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" name \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\":\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[n._v(\"String\")]),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"?\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[n._v('\"Tom\"')]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"if\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"var\")]),n._v(\" name \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" name \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"{\")]),n._v(\"\\n    name \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token string\"}},[n._v('\"Jerry\"')]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"}\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"print\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),n._v(\"name\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[n._v('//Optional(\"Tom\")')]),n._v(\"\\n\")])])]),t(\"h1\",{attrs:{id:\"_2-基本运算\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-基本运算\"}},[n._v(\"#\")]),n._v(\" 2 基本运算\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"_2-1-类型转换\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-1-类型转换\"}},[n._v(\"#\")]),n._v(\" 2.1 类型转换\")]),n._v(\" \"),t(\"p\",[n._v(\"Swift中相同类型的之间才可以进行运算，Swift中没有类似OC中的隐式类型转换，所以当两个变量类型不同时，需要进行强制类型转换。Swift是一门强类型语言，即使Int8类型和Int类型也不能直接进行运算，同样需要强制转换类型才可以。\\n强制类型转换 Int(标识符a)  、Double(标识符b)\")]),n._v(\" \"),t(\"div\",{staticClass:\"language-swift extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-swift\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" n \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"10\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" x \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\":\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[n._v(\"Int8\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"5\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" m \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"10.5\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" result \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"Double\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),n._v(\"n\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"+\")]),n._v(\" m \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[n._v(\"// Int转化为Double\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" result1 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"Int\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),n._v(\"m\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"+\")]),n._v(\" n \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[n._v(\"// Double转化为Int\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" result2 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"Int\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),n._v(\"x\"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"+\")]),n._v(\" n \"),t(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[n._v(\"// Int8 与 Int进行运算同样需要转化\")]),n._v(\"\\n\")])])]),t(\"h2\",{attrs:{id:\"_2-1-1-as使用场合\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-1-1-as使用场合\"}},[n._v(\"#\")]),n._v(\" 2.1.1 as使用场合\")]),n._v(\" \"),t(\"p\",[n._v(\"（1）从派生类转换为基类，向上转型（upcasts）\")]),n._v(\" \"),t(\"div\",{staticClass:\"language-swift extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-swift\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"class\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[n._v(\"Animal\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"{\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"}\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"class\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[n._v(\"Cat\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\":\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[n._v(\"Animal\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"{\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"}\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" cat \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token function\"}},[n._v(\"Cat\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" animal \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" cat \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"as\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[n._v(\"Animal\")]),n._v(\"\\n\")])])]),t(\"p\",[n._v(\"（2）消除二义性，数值类型转换\")]),n._v(\" \"),t(\"div\",{staticClass:\"language-swift extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-swift\"}},[t(\"code\",[t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" num1 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"42\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"as\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[n._v(\"CGFloat\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" num2 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"42\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"as\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[n._v(\"Int\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" num3 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"42.5\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"as\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[n._v(\"Int\")]),n._v(\"\\n\"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"let\")]),n._v(\" num4 \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"=\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\"(\")]),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"42\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[n._v(\"/\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token number\"}},[n._v(\"2\")]),t(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[n._v(\")\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[n._v(\"as\")]),n._v(\" \"),t(\"span\",{pre:!0,attrs:{class:\"token builtin\"}},[n._v(\"Double\")]),n._v(\"\\n\")])])]),t(\"p\",[n._v('（3）switch 语句中进行模式匹配\\n如果不知道一个对象是什么类型，你可以通过switch语法检测它的类型，并且尝试在不同的情况下使用对应的类型进行相应的处理。\\nswitch animal {\\ncase let cat as Cat:\\nprint(\"如果是Cat类型对象，则做相应处理\")\\ncase let dog as Dog:\\nprint(\"如果是Dog类型对象，则做相应处理\")\\ndefault: break\\n}\\n2.1.2 as!使用场合\\n向下转型（Downcasting）时使用。由于是强制类型转换，如果转换失败会报 runtime 运行错误。\\nclass Animal {}\\nclass Cat: Animal {}\\nlet animal :Animal  = Cat()\\nlet cat = animal as! Cat\\n2.1.3 as?使用场合\\nas? 和 as! 操作符的转换规则完全一样。但 as? 如果转换不成功的时候便会返回一个 nil 对象。成功的话返回可选类型值（optional），需要我们拆包使用。\\n由于 as? 在转换失败的时候也不会出现错误，所以对于如果能确保100%会成功的转换则可使用 as!，否则使用 as?\\nlet animal:Animal = Cat()\\nif let cat = animal as? Cat{\\nprint(\"cat is not nil\")\\n} else {\\nprint(\"cat is nil\")\\n}')]),n._v(\" \"),t(\"p\",[n._v(\"2.2 区间运算符\")]),n._v(\" \"),t(\"ol\",[t(\"li\",[n._v(\"闭区间运算符 (a...b)，定义了从a到b的一组范围，并且包含a和b。要求 a <= b\")]),n._v(\" \"),t(\"li\",[n._v(\"半开区间运算符 (a..<b)，定义了从a到b但不包括b的区间，要求a<=b，当a=b时那么返回的区间为空\")]),n._v(\" \"),t(\"li\",[n._v(\"单侧区间运算符[2...]，一般用于数组中，例如list[2...]即表示从list数组索引2开始一直到结束。注意这时2必须小于数组的count，否则编译器将会报错\\n当然也可以写成[...2]表示从0开始到2的索引，[..<2]表示从0开始到1的索引\\n//输出0到5的方法\\nfor i in 0...5 { print(i) }\\nfor i in 0..<6 { print(i) }\")])]),n._v(\" \"),t(\"p\",[n._v(\"3 逻辑分支\\n在OC中的逻辑控制，一般都会提到，if，if...else，switch等，而在swift中多了一个guard...else。\\n3.1 guard...else\\n这是在swift2.0之后推出的，能使用if...else的地方都能使用guard...else，但是反过来未必。guard一定要和else一起使用，而且使用的地方也必须是在函数中。\\nguard \"),t(\"em\",[n._v(\"判断语句\")]),n._v(' else {\\n*****\\nbreak\\\\return\\\\continue...\\n}\\n当判断语句的条件满足的时候，就会去执行语句组，但是在不满足的情况下，就会去执行else中的语句，并且必须写上break、return、continue等关键字作为结束符。\\n与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。 与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。 可以把guard近似的看做是Assert.\\n3.2 switch 特性\\n3.2.1 多条件判断\\nswitch gender {\\ncase 0 , 1 :\\nprint(\"正常人\")\\nbreak\\ndefault :\\nprint(\"其他\")\\nbreak\\n}\\n3.2.2 区间判断\\nlet score = 88\\nswitch score {\\ncase 0..<60 :\\nprint(\"不及格\")\\ncase 60..<75 :\\nprint(\"中\")\\ncase 75..<90 :\\nprint(\"良\")\\ncase 90...100 :\\nprint(\"优\")\\ndefault :\\nprint(\"不合理分数\")\\n}\\n3.2.3 其他特性')]),n._v(\" \"),t(\"ol\",[t(\"li\",[n._v(\"switch后面的()可以省略\")]),n._v(\" \"),t(\"li\",[n._v(\"case语句结束，可以不加break，系统默认帮我们加上了break，如果希望case结束时产生穿透， 去除break效果需要加上 fallthrough。\")]),n._v(\" \"),t(\"li\",[n._v(\"在每条case中必须包含至少一条可执行语句，不能为空。\")]),n._v(\" \"),t(\"li\",[n._v(\"case语句后面可以判断多个条件，每个条件之间用逗号隔开，如果任何一个条件匹配了，则会执行case下的语句\")]),n._v(\" \"),t(\"li\",[n._v('Switch可以判断多种类型，包括 浮点型，字符串类型，区间类型，元组\\n// 这里用元组举例\\nlet point = (1,1) // 类型为(Int,Int)的元组\\nswitch point {\\ncase (0, 0):\\nprint(\"(0, 0) is at the origin\")\\ncase (_, 0): // 如果不想匹配元组中的某一个值，可以用_代替\\nprint(\"((somePoint.0), 0) is on the x-axis\")\\ncase (0, _):\\nprint(\"(0, (somePoint.1)) is on the y-axis\")\\ncase (-2...2, -2...2): // 元组中使用区间匹配\\nprint(\"((somePoint.0), (somePoint.1)) is inside the box\")\\ndefault:\\nprint(\"((somePoint.0), (somePoint.1)) is outside of the box\")\\n}// prints \"(1, 1) is inside the box\"')]),n._v(\" \"),t(\"li\",[n._v('Switch可以将匹配到的值临时绑定为一个变量或者一个常量，来给case中的执行语句使用\\nlet personInfo = (name : \"tom\" , age : 20)\\nswitch personInfo {\\ncase (let x , 1..<18):\\nprint(\"未成年的人有(x)\")\\ncase (let x , 18..<100):\\nprint(\"成年的人有(x)\")\\ndefault:\\nprint(\"没有匹配的人\")\\n}\\n// print 成年的人有tom')]),n._v(\" \"),t(\"li\",[n._v(\"同时可以在case语句后面添加额外的where判断\")]),n._v(\" \"),t(\"li\",[n._v('Switch可以被打上标签循环使用\\nvar times = 0\\ntimeLoop : while times < 10 {\\ntimes += 1\\nswitch times {\\ncase 6:\\nbreak timeLoop\\ncase 4:\\ncontinue timeLoop\\ndefault:\\nprint(\"default\")\\n}\\n}\\n// print :  default default default default')])]),n._v(\" \"),t(\"p\",[n._v('4 数组\\n4.1 定义数组\\n//定义不可变数组\\nlet array = [\"name\", \"wj\", \"haha\", \"12weqw\", \"asdasdas\"] // 推导方法\\nlet array1 : Array'),t(\"String\",[n._v(' = [\"name\", \"wj\", \"haha\"]\\nlet array2 : [String] = [\"name\", \"wj\", \"haha\"]')])],1),n._v(\" \"),t(\"p\",[n._v(\"//定义可变数组（泛型定义，需要指定类型）\\nvar arrayM = Array\"),t(\"String\",[n._v(\"()\\nvar arrayM = \"),t(\"a\",{attrs:{href:\"\"}},[n._v(\"String\")]),n._v(\" // 创建了一个可变数组，使用的较多的方法\")])],1),n._v(\" \"),t(\"p\",[n._v(\"/*\")]),n._v(\" \"),t(\"ul\",[t(\"li\",[n._v(\"同时数组还为我们提供了初始化方法创建\")]),n._v(\" \"),t(\"li\",[n._v(\"repeating：表示数组存储对应类型的默认值\")]),n._v(\" \"),t(\"li\",[n._v('count：表示数组内元素的个数\\n*/\\nvar arr = Array(repeating: \"a\", count: 5)\\n4.2 可变数组的基本操作\\n// 获取数组元素个数\\nlet count = arrayM.count\\n// 同时也可以使用isEmpty Bool值属性 来对数组是否为空进行快速判断\\nif arrayM.isEmpty {}\\n// 1. 添加元素\\narrayM.append(\"xx_cc\")\\n// 也可以使用 +=运算符在数组末尾添加新的同类型元素\\narrayM += [\"xx\",\"cc\"]\\n// 使用 insert方法添加元素到指定位置\\narrayM.insert(\"js\", at: 1)\\n// 删除元素\\narrayM.remove(at: 0) // 返回被删除的元素\\narrayM.removeAll() // 删除所有的\\narrayM.removeLast() // 删除最后一个\\narrayM.removeFirst() // 删除第一个\\n// 提取元素\\nlet name = arrayM[0]\\n// 修改元素\\narrayM[0] = \"hh\"\\n// 也可以使用区间类型修改多个元素\\narrayM[2...3] = [\"haha\",\"xixi\"]\\n4.3 数组遍历\\nfor item in arrayM {\\nprint(item)\\n}\\n// 如果我们想要拿到数组中每个元组的值以及它的索引，我们可以使用enumerated()方法来返回数组中每一个元素的元组，元组中包含了元素的索引和值\\nfor (index , item) in arrayM.enumerated(){\\nprint(index)\\nprint(item)\\n}\\n4.4 可变性\\n数组和其他的集合一样，具有值语义，数组赋值时，这个数组的内容会被复制\\nswift:\\nvar x = [6,6,6]\\nvar y = x\\ny.append(6)\\ny // [6,6,6,6]\\nx // [6,6,6]')])]),n._v(\" \"),t(\"p\",[n._v('OC:\\n// NSMutableArray *x = [NSMutableArray arrayWithArray:@[@\"1\",@\"2\",@\"3\"]];\\n// NSMutableArray *y = x;\\n// [y addObject:@\"4\"];\\n// NSLog(@\"x=%@\",x); //1,2,3,4\\n// NSLog(@\"y=%@\",y); //1,2,3,4\\n在swift中 Array是以struct的形式存在的。并非OC里面的class\\n可能你会觉得这么多的复制会不会有性能上的缺点，实际上swift集合类型都使用的“写时复制”技术。 只有在复制的时候复制出来，其他时候都共享一个内部存储。\\n4.5 数组的其他操作\\nswift中不建议我们直接使用下标去访问一个数组，如array[3]\\nvar demoArray = [\"🌰\",\"🍎\",\"🍐\",\"🍇\",\"🥚\",\"🌽\",\"🌺\",\"I\"]\\n1.迭代除第1个元素外的数组元素：for x in array.dropFirst()\\n2.迭代除最后5个元素外的数组元素：for x in array.dropLast(5)\\n3.(项目中最常用到的一个方法)所有元素和其下标: for (idx, obj) in array.enumerated()\\n4.寻找指定元素的位置 if let idx = array.index {someMatchingLogic($0) }\\nif let idx = demoArray.index(where: { (obj) -> Bool in\\nif obj == \"I\"{\\nreturn true\\n}\\nreturn false\\n}) {\\nprint(\"(idx)\")//7\\n}\\n5.所有元素进行变形 array.map {someTransformation($0)}\\ndemoArray = demoArray.map { (obj) -> String in\\nreturn \"hi~(obj)\"\\n}\\nfor obj in demoArray {\\nprint(obj)// hi~🌰...\\n}\\n6.筛选符合某个标准的元素 array.filter {someCriteria($0)}\\ndemoArray = demoArray.filter { (obj) -> Bool in\\nif obj == \"🌰\" || obj == \"🍎\" || obj == \"I\"{\\nreturn true\\n}else{\\nreturn false\\n}\\n}\\nprint(demoArray)//[\"🌰\", \"🍎\", \"I\"]\\n7.两个数组变形合并 flatMap\\nlet fruit = [\"🍎\",\"🍐\",\"🍌\"]\\nlet animal = [\"🐷\"]')]),n._v(\" \"),t(\"p\",[n._v('let result = fruit.flatMap { (f) -> [String] in\\nlet newArray = animal.map({ (a) -> String in\\nreturn (a+\"eat\"+f)\\n})\\nreturn newArray\\n}\\nprint(result) //[\"🐷eat🍎\", \"🐷eat🍐\", \"🐷eat🍌\"]\\n8.切片slice\\n获取某个范围中的元素，我们可以使用切片 例如：获取除了第一个元素以外的元素集合\\nlet fruit = [\"🍎\",\"🍐\",\"🍌\"]\\nlet slice = fruit[1..<fruit.endIndex]\\nprint(slice)//[\"🍐\", \"🍌\"]\\nprint(\"(type(of: slice))\")//ArraySlice'),t(\"String\",[n._v('\\n我们得到的类型是ArraySlice 而不是Array，其实切片只是Array的一种表现形式。在开发过程中可以把它当做数组来看。 类型转换直接Array(ArraySlice)\\n5 字典\\n5.1 字典的定义\\n// 字典也用[]表示，编译器会自动区分[]中是一个个元素（数组）还是键值对（字典）\\nlet dic : Dictionary<String , Any> = [\"string\" : \"xx_cc\", \"age\" : 18 , \"height\" : 1.88]// 与数组一样，同样可以对字典进行简写\\nlet dic2 : [String : Any] = [\"string\" : \"xx_cc\", \"age\" : 18 , \"height\" : 1.88] // 推荐 这种写法更简便一些\\n//定义可变字典 var 修饰\\nvar dicM = Dictionary <String ,Any> ()\\nvar dicM1 = '),t(\"a\",{attrs:{href:\"\"}},[n._v(\"String : Any\")]),n._v('\\n// 与数组一样，如果你用一致类型的字典字面量初始化字典，就不需要写出字典的类型了\\nvar dicName = [\"xx_cc\":\"xx\",\"xx_cl\":\"cl\"]\\n5.2 可变字典的基本操作\\n// 同数组一样字典也拥有count属性和isEmpty属性来得到字典的元素个数和快速判断字典元素个数是否为0\\n//给字典添加元素\\ndicM[\"name\"] = \"Tom\"\\ndicM[\"age\"] = 18\\ndicM[\"height\"] = 1.88\\n// 删除元素\\ndicM.removeValue(forKey: \"name\") // 如果删除成功则返回被删除的值，如果字典没有这个键值对则返回nil\\ndicM.removeAll() // 我们也可以使用下标脚本语法给一个键赋值 nil来从字典当中移除一个键值对\\ndicM[\"name\"] = nil\\n// 修改元素 字典会自动索引字典中没有相同的key，如果没有就添加，如果有就修改其值\\ndicM[\"name\"] = \"Tom\"\\n// updateValue的功能同上，同样会增加或修改元素的值\\n// 如果updateValue是更新已经存在键的值，则会返回原来旧值的可选类型\\n// 如果updateValue为字典新增加了一个元素，则返回nil\\nlet oldValue = dicM.updateValue(\"Jerry\", forKey: \"name\")\\noldValue //Tom\\n5.3 字典遍历\\n// 遍历字典中所有的key\\nfor key in dic.keys {\\nprint(key)\\n}\\n// 遍历字典中所有的value\\nfor value in dic.values {\\nprint(value)\\n}\\n// 遍历字典中所有的key - value\\nfor (key,value) in dic{\\nprint(key, value)\\n}\\n// 拿到所有key 或value组成的数组\\nlet keyArr = '),t(\"a\",{attrs:{href:\"dict.keys\"}},[n._v(\"String\")]),n._v(\"\\nlet valueArr = \"),t(\"a\",{attrs:{href:\"dict.values\"}},[n._v(\"String\")]),n._v('\\n// 我们可以通过遍历其中一个字典，为第二个字典赋值，来合并两个字典\\nlet dicStr : [String : Any] = [\"name\" : \"Tom\" , \"age\" : 18]\\nvar dicStr2 : [String : Any] = [\"name\" : \"Jerry\",\"height\" : 1.88 , \"phone\" : \"110\"]\\nfor (key , value) in dicStr {\\ndicStr2[key] = value\\n}\\n5.4 字典的其他操作\\n5.4.1 字典的合并 merge\\nvar dict = [\"name\":\"Tom\",\"age\":\"18\"]\\nlet newDict = [\"name\":\"Jane\",\"age\":\"19\",\"gender\":\"M\"]\\ndict.merge(newDict) { (dictValue, newDictValue) -> String in\\nprint(dictValue)    // Tom 相同key时候的dictValue\\nprint(newDictValue)     //Jane 相同key时候的newDictValue\\nreturn newDictValue //返回你觉得应该选择的value 我这里默认都是newDictValue\\n}\\nprint(dict)[\"name\": \"Jane\", \"age\": \"19\", \"gender\": \"M\"]\\n注：闭包里面的处理是逻辑是当两个dict 有相同的key return出我们觉得合适的value.')])],1),n._v(\" \"),t(\"p\",[n._v('5.4.2 字典value的处理 mapValues\\n//字典的map方法\\nlet mapDict = dict.mapValues { (value) -> String in\\nreturn \"new\"+value\\n}\\nprint(mapDict)//[\"name\": \"newTom\", \"age\": \"new18\"]\\n这里的使用逻辑和数组中的map类似 不赘述。\\n6 集合\\n6.1 集合的定义\\n// 使用 Set'),t(\"Element\",[n._v(\"创建并初始化一个集合\\nvar letters = Set\"),t(\"Int\",[n._v(\"()\\n// 注意Set没有同数组一样对应的简写方式\\n// 也可以通过数组来创建集合\\nvar name: Set\"),t(\"String\",[n._v(' = [\"cc\", \"xx\", \"xx_cc\"]\\n6.2 集合的基本操作\\n// 通过count来访问集合内元素的个数\\nprint(name.count)\\n// 也可以通过 isEmpty快速判断count属性是否为0\\nif name.isEmpty {\\nprint(\"As far as music goes, I\\'m not picky.\")\\n}\\n// 通过insert为集合新增加一个元素\\nname.insert(\"enen\")\\n// 删除集合中的元素\\nif let nameInfo = name.remove(\"cc\") {\\nprint(\"(nameInfo)\")\\n}\\n// 如果集合中有cc这个元素那么就删除它，并且返回被删除的元素，如果没有就返回nil\\n// 我们这里使用 if let 来对返回的值进行判断，如果集合中存在被删除的参数，那么返回值不为nil，然后就会执行大括号里面的内容，如果集合中不存在该参数，那么就会返回nil，大括号中的内容就不会执行')])],1)],1)],1),n._v(\" \"),t(\"p\",[n._v('// 使用contains()方法检查集合中是否包含了特定的元素\\nif name.contains(\"xx\") {\\nprint(\"xx is in set\")\\n}\\n使用 intersection('),t(\"em\",[n._v(\"😃 方法来创建一个只包含两个集合共有值的新合集。\\n使用 symmetricDifference(\")]),n._v(\"😃 方法来创建一个只包含两个集合各自有的非共有值的新集合。\\n使用 union(\"),t(\"em\",[n._v(\":)方法来创建一个包含两个集合所有值的新集合；\\n使用 subtracting(\")]),n._v(\":)方法来创建一个两个集合当中不包含某个集合值的新合集。\")]),n._v(\" \"),t(\"p\",[n._v('使用“相等”运算符 ( == )来判断两个集合是否包含有相同的值；\\n使用 isSubset(of:) 方法来确定一个集合的所有值是被某合集包含；\\n使用 isSuperset(of:)方法来确定一个集合是否包含某个合集的所有值；\\n使用 isStrictSubset(of:) 或者 isStrictSuperset(of:)方法来确定是个集合是否为某一个集合的子集或者超集，但并不相等；\\n使用 isDisjoint(with:)方法来判断两个集合是否拥有完全不同的值。\\n7 元组\\n元组是swift中独有的，OC没有对应的类型；元组定义的是一组数据类型，组成元组数据类型的可以称之为“元素”。而元组的使用，一般是用做于函数中的返回值。\\n7.1 元组的使用\\nlet info = (\"name\", 18, 1.88)\\n// 取出元组中的各元素\\ninfo.0\\ninfo.1\\ninfo.2')]),n._v(\" \"),t(\"p\",[n._v('// 取个别名\\nlet info1 = (name : \"wj\", age : 18, height : 1.88)\\ninfo1.name\\ninfo1.age\\ninfo1.height\\n//书写格式类似字典的定义，但是这却有别于字典，首先是字典是用中括号进行括起来的，而元组是用小括号进行括起来的；其次就是字典的这个key一般用字符串，当然也可能用其他的数据类型，但是在元组中，这个别名没有特殊的要求，随便怎么写都是可以的，在用到info这个元组的时候直接用点语法就可以将别名显示出来，和最基本的写法的底层是一致的。')]),n._v(\" \"),t(\"p\",[n._v(\"//对应元素\\nlet (name, age, height) = (\\\"wj\\\", 18, 1.88)\\nname\\nage\\nheight\\n8 可选型\\n可选型是Swift语言的特色之一，用于表达一个变量/常量可以为nil或者非nil值。可选类型其本质是一个枚举型，包含none和some两种类型。Optional.none就是nil, 非nil的原始值会通过some(T)包装，这也是为什么在使用Optional的时候要拆包的原因, 就是为了从enum里取出来原始值。\\nSwift中只有可选类型才能被赋值为nil，其他类型都不能赋值为nil\\nOC中当一个值不在使用时，我们可以将它赋值为0（基本数据类型）或者赋值为nil（对象类型），但是在Swift中，nil是一个特殊的类型，同String，Int相同。而Swift是一门强类型语言，类型不匹配无法赋值。所以只有可选类型才能被赋值为nil。被可选类型修饰的值则表示该值有可能为nil。\\n8.1 可选类型的定义\\n// 首先我们尝试给String变量赋值为nil编译器报错\\n// Nil cannot initialize specified type 'String'\\n// var name : String = nil\")]),n._v(\" \"),t(\"p\",[n._v(\"// 定义可选类型 Optional表示可选类型 泛型集合\\nvar name : Optional\"),t(\"String\",[n._v(\" = nil\\n// 简写 String？表示可选类型的string\\nvar name1 : String? = nil\\n// 问号明确了它储存的值是一个可选项，意思就是说它可能包含某些 String  值，或者为nil。\")])],1),n._v(\" \"),t(\"p\",[n._v('// 给可选类型进行赋值\\nname1 = Optional(\"xx_cc\") // 方式一\\nname1 = \"xx_cc\" // 方式二 编译器会自动加上 Optional()\\n8.2 解包和绑定\\n获取可选型内容需要加！解包，一般使用绑定。\\nvar name : String? = nil\\nif let name = name {\\nprint(name)\\n}// 中间值采用就近原则，会使用定义比较近的那个name\\n8.2.1 可与 Bool 联合判断\\nif let obj = Optional , Bool {\\n/// 前面有值且后面Bool为true执行\\n}\\n8.2.2 多 let 并列判断\\nif let obj1 = Optional1, let obj2 = Optional2, ....{\\n///当上面的let判断都有值的时候执行\\n}\\n8.3 空合运算符\\n空合运算符（nil coalecse）“a ?? b” 将对可选类型a进行空判断，如果a非nil就对其进行解包，否则就返回一个默认值b\\nvar name: String? = \"鹿晗\"\\nvar address: String? = nil\\nprint((name ?? \"XXX\"),\"来自\", (address ?? \"未知地区\"))\\n// print结果为：鹿晗 来自 未知地区\\n8.4 可选链\\n可选链(optional chaining)为一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。\\nlet name = person.dog?.name?.lowercased()')]),n._v(\" \"),t(\"p\",[n._v(\"var voidCallback:(()-> Void)?\\n///对于闭包调用的两种写法\\n//❌不推荐\\nif voidCallback != nil {\\nvoidCallback!()\\n}\"),t(\"br\"),n._v('\\n//✅ 推荐\\nvoidCallvack?()\\n8.5 可选值 map\\n///将一个网络图片加载出来的奇淫方法！！！\\nlet urlString = \"http://www.objc.io/logo.png\"\\nlet view = URL(string: urlString)\\n.flatMap { (url) -> Data? in\\ntry? Data(contentsOf: url)\\n}\\n.flatMap { (data) -> UIImage? in\\nUIImage(data: data)\\n}\\n.map { (image) -> UIImageView in\\nUIImageView(image: image)\\n}')]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",[t(\"code\",[n._v(\"if let view = view {\\n    UIView().addSubview(view)\\n}\\n\")])])]),t(\"p\",[n._v('利用swift中的$0语法简化上面的代码\\nlet view2 = URL(string: urlString)\\n.flatMap {\\ntry? Data(contentsOf: $0)\\n}\\n.flatMap {\\nUIImage(data: $0)\\n}\\n.map {\\nUIImageView(image: $0)\\n}\\nif let view2 = view2 {\\nUIView().addSubview(view2)\\n}\\n使用flatMap过滤nil\\n目的:我们想要求一个字符串数组中的数字和。\\nlet numbers = [\"1\",\"2\",\"3\",\"4\",\"add\"]')]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",[t(\"code\",[n._v(\"var sum = 0\\nfor case let i? in numbers.map({\\n    Int($0)\\n}) {\\n    sum += i// Int($0)为nil就不走这里了\\n}\\n//        sum的值为10\\n\\n///当我们用?? 把nil替换成0\\nnumbers.map { Int($0) }.reduce(0) { $0 + ($1 ?? 0)} //10\\n\\n///在标准库中flatMap的作用可能正是你想要\\nnumbers.flatMap { Int($0) }.reduce(0, +) // 10\\n\")])])]),t(\"p\",[n._v('8.6 强制解包的时机\\n几种强制解包的观点 1、绝不使用 2、代码逻辑更清晰的时候使用 3、不可避免的时候使用\\n我们通过特定的方法让可选值变成必选值，从而巧妙的避开强制解包。 可以先用filter去对序列进行排空处理，再通过map进行映射和排序。 如下面这个例子：\\nlet ages = [\"Tom\":17,\"Jerry\":16]\\n//有强制解包\\nages.keys.filter { name in ages[name]! < 50 }.sorted()\\n//巧妙的避开了强制解包\\nages.filter { (_, age) in age < 50 }\\n.map { (name, _) in name }\\n.sorted()\\n8.7 隐式可选值\\n定义：无论什么时候使用都会自动强制解包的可选值。变量或常量后加上!的都是隐式可选变量/常量。首先该变量或常量满足可选类型，其可被当成一般的变量/常量来使用，而不需要每次都验证是否有值。')]),n._v(\" \"),t(\"p\",[n._v(\"出现场景一：\\n调用OC有返回值的方法，其返回值就是隐式可选值。\")]),n._v(\" \"),t(\"p\",[n._v(\"出现场景二：\\n隐式可选型主要用在一个变量/常量在定义瞬间完成之后值一定会存在的情况，例如在类的初始化过程中等。\")])])}),[],!1,null,null,null);a.default=s.exports}}]);","extractedComments":[]}